<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
  <title>Axolotl Jumper</title>
  <link rel="manifest" href="manifest.json">
  <style>
    html,
    body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #0c6ba6;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      user-select: none;
      -webkit-user-select: none;
    }

    canvas {
      display: block;
    }

    #ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .screen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.45);
      backdrop-filter: blur(4px);
      transition: opacity 0.3s;
      pointer-events: auto;
      z-index: 20;
    }

    .hidden {
      opacity: 0;
      pointer-events: none;
    }

    h1 {
      font-size: 48px;
      margin: 0 0 20px;
      text-shadow: 0 4px 0 #000, 0 0 20px rgba(0, 255, 255, 0.5);
      color: #e0f7fa;
      text-align: center;
      line-height: 1.1;
    }

    p {
      font-size: 20px;
      margin: 10px 0;
      text-shadow: 0 2px 0 #000;
    }

    button {
      margin-top: 30px;
      padding: 15px 40px;
      font-size: 24px;
      font-weight: bold;
      color: #004d40;
      background: linear-gradient(to bottom, #80deea, #26c6da);
      border: none;
      border-radius: 50px;
      cursor: pointer;
      box-shadow: 0 6px 0 #006064, 0 10px 10px rgba(0, 0, 0, 0.3);
      transition: transform 0.1s, box-shadow 0.1s;
      font-family: inherit;
    }

    button:active {
      transform: translateY(4px);
      box-shadow: 0 2px 0 #006064, 0 4px 4px rgba(0, 0, 0, 0.3);
    }

    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      font-size: 24px;
      font-weight: bold;
      text-shadow: 2px 2px 0 #000;
      pointer-events: none;
      z-index: 10;
    }

    #controls-hint {
      position: absolute;
      bottom: 20px;
      width: 100%;
      text-align: center;
      font-size: 16px;
      opacity: 0.8;
      text-shadow: 1px 1px 2px #000;
      pointer-events: none;
    }
  </style>
</head>

<body>
  <div id="ui-layer">
    <div id="hud">Score: 0</div>

    <div id="start-screen" class="screen">
      <h1>Axolotl Jumper</h1>
      <p>Help the axolotl climb high!</p>
      <button id="start-btn">PLAY</button>
    </div>

    <div id="game-over-screen" class="screen hidden">
      <h1>Game Over</h1>
      <p id="final-score">Score: 0</p>
      <p id="best-score">Best: 0</p>
      <button id="restart-btn">AGAIN</button>
    </div>

    <div id="controls-hint">
      Desktop: Arrow Keys / WASD &nbsp;&bull;&nbsp; Mobile: Tap Left / Right
    </div>
  </div>
  <canvas id="game"></canvas>
  <script>
    (() => {
      const canvas = document.getElementById('game');
      const ctx = canvas.getContext('2d');

      // UI Elements
      const hudDiv = document.getElementById('hud');
      const startScreen = document.getElementById('start-screen');
      const gameOverScreen = document.getElementById('game-over-screen');
      const finalScoreSpan = document.getElementById('final-score');
      const bestScoreSpan = document.getElementById('best-score');
      const startBtn = document.getElementById('start-btn');
      const restartBtn = document.getElementById('restart-btn');

      // Constants
      const STORAGE_KEY = 'axolotlBest';
      const SPRITE_COLS = 2;
      const SPRITE_ROWS = 2;
      const PLAT_COLS = 3;

      const PLATFORM_NORMAL = 0;
      const PLATFORM_CRACKED = 1;
      const PLATFORM_SPRING = 2;

      // Audio Context
      const AudioContext = window.AudioContext || window.webkitAudioContext;
      let audioCtx;

      function initAudio() {
        if (!audioCtx) {
          audioCtx = new AudioContext();
        } else if (audioCtx.state === 'suspended') {
          audioCtx.resume();
        }
      }

      function playSound(type) {
        if (!audioCtx) return;
        const t = audioCtx.currentTime;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();

        osc.connect(gain);
        gain.connect(audioCtx.destination);

        if (type === 'jump') {
          osc.type = 'sine';
          osc.frequency.setValueAtTime(300, t);
          osc.frequency.linearRampToValueAtTime(500, t + 0.1);
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.1);
          osc.start(t);
          osc.stop(t + 0.1);
        } else if (type === 'spring') {
          osc.type = 'triangle';
          osc.frequency.setValueAtTime(200, t);
          osc.frequency.linearRampToValueAtTime(600, t + 0.4);
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.4);
          osc.start(t);
          osc.stop(t + 0.4);
        } else if (type === 'collect') {
          osc.type = 'sine';
          osc.frequency.setValueAtTime(800, t);
          osc.frequency.exponentialRampToValueAtTime(1400, t + 0.1);
          gain.gain.setValueAtTime(0.3, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.25);
          osc.start(t);
          osc.stop(t + 0.25);
        } else if (type === 'hit') {
          osc.type = 'sawtooth';
          osc.frequency.setValueAtTime(150, t);
          osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
          gain.gain.setValueAtTime(0.4, t);
          gain.gain.linearRampToValueAtTime(0, t + 0.3);
          osc.start(t);
          osc.stop(t + 0.3);
        }
      }

      // Game/Physics State
      const player = {
        x: 0, y: 0, vx: 0, vy: 0, w: 48, h: 48,
        speed: 6, jumpStrength: 17
      };

      const images = {
        sprite: new Image(),
        platforms: new Image(),
        background: new Image()
      };
      images.sprite.src = 'axolotl.png';
      images.platforms.src = 'platforms.png';
      images.background.src = 'background.png';

      let width, height;
      let frameW = 48, frameH = 48, platW = 96, platH = 32;
      let frameIndex = 0, frameTimer = 0;

      let gameState = 'START'; // START, PLAYING, GAMEOVER
      let score = 0;
      let cameraY = 0;
      let highScore = parseInt(localStorage.getItem(STORAGE_KEY) || '0', 10);

      let platforms = [];
      let powerUps = [];
      let hazards = [];
      let particles = [];

      let leftPressed = false, rightPressed = false;
      let lastTime = 0;

      // Helpers
      function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
      }
      window.addEventListener('resize', resize);
      resize();

      function clamp(v, min, max) { return Math.max(min, Math.min(max, v)); }
      function randomRange(min, max) { return min + Math.random() * (max - min); }
      function overlaps(c, r) { // circle vs rect
        let closestX = clamp(c.x, r.x, r.x + r.w);
        let closestY = clamp(c.y, r.y, r.y + r.h);
        let dx = c.x - closestX;
        let dy = c.y - closestY;
        return dx * dx + dy * dy <= c.r * c.r;
      }

      // Particle System
      function spawnParticles(x, y, color, count = 8) {
        for (let i = 0; i < count; i++) {
          particles.push({
            x: x, y: y,
            vx: randomRange(-4, 4),
            vy: randomRange(-4, 4),
            life: 1.0,
            color: color
          });
        }
      }

      function updateParticles(ts) {
        for (let i = particles.length - 1; i >= 0; i--) {
          let p = particles[i];
          p.x += p.vx * ts;
          p.y += p.vy * ts;
          p.life -= 0.03 * ts;
          if (p.life <= 0) particles.splice(i, 1);
        }
      }

      function drawParticles() {
        for (let p of particles) {
          if (p.y - cameraY > height) continue;
          ctx.globalAlpha = p.life;
          ctx.fillStyle = p.color;
          ctx.fillRect(p.x, p.y - cameraY, 4, 4);
        }
        ctx.globalAlpha = 1.0;
      }

      // Level Gen
      function getDifficulty() { return Math.min(1.35, cameraY / 8500); }

      function addPlatform(y) {
        const diff = getDifficulty();
        let type = PLATFORM_NORMAL;
        const r = Math.random();
        // 16-33% cracked, 15-8% spring based on diff
        if (r < 0.16 + diff * 0.17) type = PLATFORM_CRACKED;
        else if (r < 0.16 + diff * 0.17 + Math.max(0.06, 0.15 - diff * 0.07)) type = PLATFORM_SPRING;

        const p = {
          x: randomRange(0, Math.max(1, width - platW)),
          y: y,
          type: type,
          broken: false,
          w: platW, h: platH
        };
        platforms.push(p);

        // Collectibles & Hazards
        if (Math.random() < 0.11) {
          powerUps.push({ type: 'bubble', x: p.x + platW / 2, y: p.y - 30, r: 12 });
        } else if (Math.random() < 0.2 + diff * 0.1) {
          // extra pearl chance
        }

        if (Math.random() < 0.05 + diff * 0.1) {
          hazards.push({
            x: randomRange(50, width - 50),
            y: y - randomRange(60, 100),
            r: 18,
            vx: (Math.random() < 0.5 ? -1 : 1) * randomRange(1, 2),
            phase: Math.random() * 6.28
          });
        }
      }

      function recycle(limitY) {
        // Remove old
        platforms = platforms.filter(p => p.y - cameraY <= height + 200);
        powerUps = powerUps.filter(p => p.y - cameraY <= height + 200);
        hazards = hazards.filter(h => h.y - cameraY <= height + 200);

        // Add new
        while (platforms.length < 15) {
          let topY = cameraY + height;
          // find highest platform (physically lowest Y value)
          let highest = platforms[0];
          for (let p of platforms) if (p.y < highest.y) highest = p;

          const diff = getDifficulty();
          const minGap = 90 + diff * 45;
          const maxGap = 140 + diff * 65;
          addPlatform(highest.y - randomRange(minGap, maxGap));
        }
      }

      // Core Game Logic
      function setGameOver(reason) {
        gameState = 'GAMEOVER';
        if (score > highScore) {
          highScore = score;
          localStorage.setItem(STORAGE_KEY, highScore);
        }
        playSound('hit');
        finalScoreSpan.innerText = 'Score: ' + score;
        bestScoreSpan.innerText = 'Best: ' + highScore;
        gameOverScreen.classList.remove('hidden');
        hudDiv.classList.add('hidden');
      }

      function resetGame() {
        initAudio();
        gameState = 'PLAYING';
        score = 0;
        cameraY = 0;
        platforms = [];
        powerUps = [];
        hazards = [];
        particles = [];

        player.x = width / 2 - 24;
        player.y = height - 200;
        player.vx = 0;
        player.vy = -12; // Initial pop

        // Initial platforms
        let y = height - 50;
        platforms.push({ x: width / 2 - 48, y: y, type: PLATFORM_NORMAL, w: platW, h: platH });
        for (let i = 0; i < 15; i++) {
          y -= 110;
          addPlatform(y);
        }

        startScreen.classList.add('hidden');
        gameOverScreen.classList.add('hidden');
        hudDiv.classList.remove('hidden');

        playSound('jump');
        lastTime = performance.now();
      }

      function update(dt) {
        if (gameState !== 'PLAYING') return;

        // Time Scale (normalize to 60fps)
        // if dt = 16ms (0.016s), ts = 1.
        const ts = dt * 60;

        // Horizontal Movement
        if (leftPressed) player.vx = -player.speed;
        else if (rightPressed) player.vx = player.speed;
        else player.vx = 0;

        player.x += player.vx * ts;

        // Gravity
        player.vy += 0.52 * ts;
        if (player.vy > 20) player.vy = 20; // term velocity
        player.y += player.vy * ts;

        // Wrap around
        if (player.x > width) player.x = -player.w;
        else if (player.x + player.w < 0) player.x = width;

        // Collisions (only falling)
        if (player.vy > 0) {
          const pBottom = player.y + player.h;
          const pCenterX = player.x + player.w / 2;

          for (let p of platforms) {
            if (p.broken) continue;
            // Simple AABB check for feet
            if (pCenterX > p.x + 5 && pCenterX < p.x + p.w - 5 &&
              pBottom >= p.y && pBottom <= p.y + 18 + player.vy * ts) { // slightly generous hit detection scaled by speed

              // Landed
              if (p.type === PLATFORM_CRACKED) {
                p.broken = true;
                playSound('hit');
                spawnParticles(p.x + p.w / 2, p.y, '#8d6e63');
                player.vy = -player.jumpStrength * 0.9;
              } else if (p.type === PLATFORM_SPRING) {
                playSound('spring');
                player.vy = -player.jumpStrength * 1.6;
                spawnParticles(p.x + p.w / 2, p.y, '#81c784');
              } else {
                playSound('jump');
                player.vy = -player.jumpStrength;
                spawnParticles(p.x + p.w / 2, p.y, '#aed581', 3);
              }
            }
          }
        }

        // Camera / Scroll
        const cutoff = height * 0.45;
        if (player.y < cutoff) {
          const diff = cutoff - player.y;
          player.y = cutoff;
          cameraY += diff;
          score += Math.floor(diff);
          recycle(cameraY);
        }

        // Powerups
        for (let i = powerUps.length - 1; i >= 0; i--) {
          let pu = powerUps[i];
          if (overlaps({ x: pu.x, y: pu.y, r: pu.r }, player)) {
            playSound('collect');
            spawnParticles(pu.x, pu.y, '#fff');
            // Bubble boost
            if (pu.type === 'bubble') {
              player.vy = Math.min(player.vy, -22);
              score += 200;
            }
            powerUps.splice(i, 1);
          }
        }

        // Hazards
        for (let h of hazards) {
          h.x += h.vx * ts;
          h.phase += 0.1 * ts;
          if (h.x < h.r || h.x > width - h.r) h.vx *= -1;

          if (overlaps({ x: h.x, y: h.y + Math.sin(h.phase) * 4, r: h.r * 0.8 }, player)) {
            setGameOver('Stung!');
          }
        }

        // Fall Death
        if (player.y - cameraY > height + 50) {
          setGameOver('Fell!');
        }

        updateParticles(ts);

        // Animation
        frameTimer += ts;
        if (frameTimer > 10) {
          frameTimer = 0;
          frameIndex = (frameIndex + 1) % 4;
        }

        hudDiv.innerText = 'Score: ' + score + ' (Lv ' + (1 + Math.floor(cameraY / 2500)) + ')';
      }

      function draw() {
        ctx.clearRect(0, 0, width, height);

        // Background
        const bgH = images.background.height || height;
        // Parallax: As cameraY (height climbed) increases, we want the background to scroll DOWN.
        // So we add cameraY to the offset instead of subtracting, or adjust the modulo logic.
        // Original: const off = ((-cameraY * 0.3) % bgH + bgH) % bgH;
        // New:
        const parallax = cameraY * 0.3;
        const off = (parallax % bgH); // reduced complexity

        // Draw 3 tiles to cover all scroll positions
        // We draw at -bgH + off, off, and bgH + off.
        // If off increases (camera goes up), the background moves down (positive Y).
        ctx.drawImage(images.background, 0, (off - bgH), width, bgH);
        ctx.drawImage(images.background, 0, off, width, bgH);
        ctx.drawImage(images.background, 0, (off + bgH), width, bgH);

        // Platforms
        for (let p of platforms) {
          if (p.broken) continue;
          // frame calc
          let sx = p.type * 96;
          ctx.drawImage(images.platforms, sx, 0, 96, 32, p.x, p.y - cameraY, 96, 32);
        }

        // Powerups
        ctx.lineWidth = 2;
        for (let pu of powerUps) {
          let y = pu.y - cameraY;
          ctx.beginPath();
          ctx.arc(pu.x, y, pu.r, 0, 6.28);
          ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.fill();
          ctx.strokeStyle = '#fff';
          ctx.stroke();
        }

        // Hazards
        for (let h of hazards) {
          let y = h.y - cameraY + Math.sin(h.phase) * 4;
          ctx.fillStyle = '#ff5252';
          ctx.beginPath(); ctx.arc(h.x, y, h.r, 0, 6.28); ctx.fill();
          // tentacles
          ctx.strokeStyle = '#ff8a80';
          for (let i = -2; i <= 2; i++) {
            ctx.beginPath();
            ctx.moveTo(h.x + i * 4, y);
            ctx.lineTo(h.x + i * 4 + Math.sin(h.phase + i) * 6, y + 25);
            ctx.stroke();
          }
        }

        drawParticles();

        // Player
        if (gameState !== 'GAMEOVER' || (player.y - cameraY < height)) {
          let col = frameIndex % 2;
          let row = Math.floor(frameIndex / 2);
          ctx.drawImage(images.sprite, col * 48, row * 48, 48, 48, player.x, player.y - cameraY, 48, 48);
        }
      }

      function loop() {
        const now = performance.now();
        const dt = Math.min((now - lastTime) / 1000, 0.1);
        lastTime = now;

        update(dt);
        draw();
        requestAnimationFrame(loop);
      }

      // Inputs
      const setDir = (x) => {
        leftPressed = x < width / 2;
        rightPressed = !leftPressed;
      };

      window.addEventListener('keydown', e => {
        if (['ArrowLeft', 'KeyA'].includes(e.code)) leftPressed = true;
        if (['ArrowRight', 'KeyD'].includes(e.code)) rightPressed = true;
      });
      window.addEventListener('keyup', e => {
        if (['ArrowLeft', 'KeyA'].includes(e.code)) leftPressed = false;
        if (['ArrowRight', 'KeyD'].includes(e.code)) rightPressed = false;
      });

      canvas.addEventListener('touchstart', e => { e.preventDefault(); setDir(e.touches[0].clientX); }, { passive: false });
      canvas.addEventListener('touchmove', e => { e.preventDefault(); setDir(e.touches[0].clientX); }, { passive: false });
      canvas.addEventListener('touchend', e => { e.preventDefault(); leftPressed = rightPressed = false; }, { passive: false });

      startBtn.onclick = resetGame;
      restartBtn.onclick = resetGame;

      // Init
      images.sprite.onload = () => {
        // Auto-size if needed, simplified here
        requestAnimationFrame(loop);
      };
    })();

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', function () {
        navigator.serviceWorker.register('service-worker.js').catch(function (err) {
          console.error('Service worker registration failed:', err);
        });
      });
    }
  </script>
</body>

</html>